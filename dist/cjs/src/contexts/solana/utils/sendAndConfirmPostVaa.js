"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPostSignedVaaTransactions = exports.postVaa = exports.postVaaWithRetry = void 0;
const web3_js_1 = require("@solana/web3.js");
const utils_1 = require("./utils");
const wormhole_1 = require("./wormhole");
const wormhole_2 = require("../../../vaa/wormhole");
/**
 * @category Solana
 */
async function postVaaWithRetry(connection, signTransaction, wormholeProgramId, payer, vaa, maxRetries, commitment) {
    const { unsignedTransactions, signers } = await createPostSignedVaaTransactions(connection, wormholeProgramId, payer, vaa, commitment);
    const postVaaTransaction = unsignedTransactions.pop();
    const responses = await (0, utils_1.sendAndConfirmTransactionsWithRetry)(connection, (0, utils_1.modifySignTransaction)(signTransaction, ...signers), payer.toString(), unsignedTransactions, maxRetries);
    //While the signature_set is used to create the final instruction, it doesn't need to sign it.
    responses.push(...(await (0, utils_1.sendAndConfirmTransactionsWithRetry)(connection, signTransaction, payer.toString(), [postVaaTransaction], maxRetries)));
    return responses;
}
exports.postVaaWithRetry = postVaaWithRetry;
/**
 * @category Solana
 */
async function postVaa(connection, signTransaction, wormholeProgramId, payer, vaa, options, asyncVerifySignatures = true) {
    const { unsignedTransactions, signers } = await createPostSignedVaaTransactions(connection, wormholeProgramId, payer, vaa, options?.commitment);
    const postVaaTransaction = unsignedTransactions.pop();
    const verifySignatures = async (transaction) => (0, utils_1.signSendAndConfirmTransaction)(connection, payer, (0, utils_1.modifySignTransaction)(signTransaction, ...signers), transaction, options);
    const output = [];
    if (asyncVerifySignatures) {
        const verified = await Promise.all(unsignedTransactions.map(async (transaction) => verifySignatures(transaction)));
        output.push(...verified);
    }
    else {
        for (const transaction of unsignedTransactions) {
            output.push(await verifySignatures(transaction));
        }
    }
    output.push(await (0, utils_1.signSendAndConfirmTransaction)(connection, payer, signTransaction, postVaaTransaction, options));
    return output;
}
exports.postVaa = postVaa;
/**
 * @category Solana
 *
 * Send transactions for `verify_signatures` and `post_vaa` instructions.
 *
 * Using a signed VAA, execute transactions generated by {@link verifySignatures} and
 * {@link postVaa}. At most 4 transactions are sent (up to 3 from signature verification
 * and 1 to post VAA data to an account).
 *
 * @param {Connection} connection - Solana web3 connection
 * @param {PublicKeyInitData} wormholeProgramId - wormhole program address
 * @param {web3.Keypair} payer - transaction signer address
 * @param {Buffer} signedVaa - bytes of signed VAA
 * @param {Commitment} [options] - Solana commitment
 *
 */
async function createPostSignedVaaTransactions(connection, wormholeProgramId, payer, vaa, commitment) {
    const parsed = (0, wormhole_2.isBytes)(vaa) ? (0, wormhole_2.parseVaa)(vaa) : vaa;
    const signatureSet = web3_js_1.Keypair.generate();
    const verifySignaturesInstructions = await (0, wormhole_1.createVerifySignaturesInstructions)(connection, wormholeProgramId, payer, parsed, signatureSet.publicKey, commitment);
    const unsignedTransactions = [];
    for (let i = 0; i < verifySignaturesInstructions.length; i += 2) {
        unsignedTransactions.push(new web3_js_1.Transaction().add(...verifySignaturesInstructions.slice(i, i + 2)));
    }
    unsignedTransactions.push(new web3_js_1.Transaction().add((0, wormhole_1.createPostVaaInstruction)(connection, wormholeProgramId, payer, parsed, signatureSet.publicKey)));
    return {
        unsignedTransactions,
        signers: [signatureSet],
    };
}
exports.createPostSignedVaaTransactions = createPostSignedVaaTransactions;
//# sourceMappingURL=sendAndConfirmPostVaa.js.map